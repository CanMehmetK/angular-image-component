{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/platform-browser\";\nexport class ImageComponent {\n  constructor(domSanitizer) {\n    this.domSanitizer = domSanitizer;\n    this.multiple = false;\n    this.uFormControlName = 'file';\n    this.marginLeft = '0px';\n    this.maxSize = {\n      width: 0,\n      height: 0\n    };\n    this.moveTypes = MoveTypes;\n    this.imageVisible = false;\n    this.transform = {};\n    this.allowMoveImage = false;\n    this.cropper = {\n      x1: -100,\n      y1: -100,\n      x2: 10000,\n      y2: 10000\n    };\n    this.disabled = false;\n    this.imageCropped = new EventEmitter();\n    this.startCropImage = new EventEmitter();\n    this.imageLoaded = new EventEmitter();\n    this.cropperReady = new EventEmitter();\n    this.loadImageFailed = new EventEmitter();\n    this.transformChange = new EventEmitter();\n    this.Hammer = (window === null || window === void 0 ? void 0 : window['Hammer']) || null;\n    this.settings = new CropperSettings();\n    this.format = this.settings.format;\n    this.maintainAspectRatio = this.settings.maintainAspectRatio;\n    this.aspectRatio = this.settings.aspectRatio;\n    this.resizeToWidth = this.settings.resizeToWidth;\n    this.resizeToHeight = this.settings.resizeToHeight;\n    this.cropperMinWidth = this.settings.cropperMinWidth;\n    this.cropperMinHeight = this.settings.cropperMinHeight;\n    this.cropperMaxHeight = this.settings.cropperMaxHeight;\n    this.cropperMaxWidth = this.settings.cropperMaxWidth;\n    this.cropperStaticWidth = this.settings.cropperStaticWidth;\n    this.cropperStaticHeight = this.settings.cropperStaticHeight;\n    this.canvasRotation = this.settings.canvasRotation;\n    this.initialStepSize = this.settings.initialStepSize;\n    this.roundCropper = this.settings.roundCropper;\n    this.onlyScaleDown = this.settings.onlyScaleDown;\n    this.imageQuality = this.settings.imageQuality;\n    this.autoCrop = this.settings.autoCrop;\n    this.backgroundColor = this.settings.backgroundColor;\n    this.containWithinAspectRatio = this.settings.containWithinAspectRatio;\n    this.hideResizeSquares = this.settings.hideResizeSquares;\n    this.alignImage = this.settings.alignImage;\n    this.setImageMaxSizeRetries = 0;\n  }\n\n  ngOnInit() {}\n\n  getImageBase64() {\n    return this.domSanitizer.bypassSecurityTrustResourceUrl(this.base64Image);\n    return '';\n  }\n\n  onFileSelected($event) {\n    console.log($event);\n    const fileInput = $event.target;\n    const reader = new FileReader();\n\n    reader.onload = x => {\n      this.base64Image = reader.result.toString();\n      if (this.uFormGroup) this.uFormGroup.get(this.uFormControlName).setValue(reader.result);\n      this.getImageBase64();\n    };\n\n    reader.readAsDataURL(fileInput.files[0]);\n  }\n\n  ngOnChanges(changes) {\n    var _a;\n\n    this.onChangesUpdateSettings(changes);\n    this.onChangesInputImage(changes);\n\n    if (((_a = this.loadedImage) === null || _a === void 0 ? void 0 : _a.original.image.complete) && (changes['containWithinAspectRatio'] || changes['canvasRotation'])) {\n      this.loadImageService.transformLoadedImage(this.loadedImage, this.settings).then(res => this.setLoadedImage(res)).catch(err => this.loadImageError(err));\n    }\n\n    if (changes['cropper'] || changes['maintainAspectRatio'] || changes['aspectRatio']) {\n      this.setMaxSize();\n      this.setCropperScaledMinSize();\n      this.setCropperScaledMaxSize();\n\n      if (this.maintainAspectRatio && (changes['maintainAspectRatio'] || changes['aspectRatio'])) {\n        this.resetCropperPosition();\n      } else if (changes['cropper']) {\n        this.checkCropperPosition(false);\n        this.doAutoCrop();\n      }\n\n      this.cd.markForCheck();\n    }\n\n    if (changes['transform']) {\n      this.transform = this.transform || {};\n      this.setCssTransform();\n      this.doAutoCrop();\n      this.cd.markForCheck();\n    }\n  }\n\n  ngOnInit() {\n    this.settings.stepSize = this.initialStepSize;\n    this.activatePinchGesture();\n  }\n\n  imageLoadedInView() {\n    if (this.loadedImage != null) {\n      this.imageLoaded.emit(this.loadedImage);\n      this.setImageMaxSizeRetries = 0;\n      setTimeout(() => this.checkImageMaxSizeRecursively());\n    }\n  }\n\n  onResize() {\n    if (!this.loadedImage) {\n      return;\n    }\n\n    this.resizeCropperPosition();\n    this.setMaxSize();\n    this.setCropperScaledMinSize();\n    this.setCropperScaledMaxSize();\n  }\n\n  resetCropperPosition() {\n    this.cropperPositionService.resetCropperPosition(this.sourceImage, this.cropper, this.settings);\n    this.doAutoCrop();\n    this.imageVisible = true;\n  }\n\n  keyboardAccess(event) {\n    this.changeKeyboardStepSize(event);\n    this.keyboardMoveCropper(event);\n  }\n\n  startMove(event, moveType, position = null) {\n    var _a, _b;\n\n    if (this.disabled || ((_a = this.moveStart) === null || _a === void 0 ? void 0 : _a.active) && ((_b = this.moveStart) === null || _b === void 0 ? void 0 : _b.type) === MoveTypes.Pinch || moveType === MoveTypes.Drag && !this.allowMoveImage) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    }\n\n    this.moveStart = Object.assign({\n      active: true,\n      type: moveType,\n      position,\n      transform: Object.assign({}, this.transform),\n      clientX: this.cropperPositionService.getClientX(event),\n      clientY: this.cropperPositionService.getClientY(event)\n    }, this.cropper);\n  }\n\n  startPinch(event) {\n    if (!this.safeImgDataUrl) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    }\n\n    this.moveStart = Object.assign({\n      active: true,\n      type: MoveTypes.Pinch,\n      position: 'center',\n      clientX: this.cropper.x1 + (this.cropper.x2 - this.cropper.x1) / 2,\n      clientY: this.cropper.y1 + (this.cropper.y2 - this.cropper.y1) / 2\n    }, this.cropper);\n  }\n\n  moveImg(event) {\n    var _a, _b;\n\n    if (this.moveStart.active) {\n      if (event.stopPropagation) {\n        event.stopPropagation();\n      }\n\n      if (event.preventDefault) {\n        event.preventDefault();\n      }\n\n      if (this.moveStart.type === MoveTypes.Move) {\n        this.cropperPositionService.move(event, this.moveStart, this.cropper);\n        this.checkCropperPosition(true);\n      } else if (this.moveStart.type === MoveTypes.Resize) {\n        if (!this.cropperStaticWidth && !this.cropperStaticHeight) {\n          this.cropperPositionService.resize(event, this.moveStart, this.cropper, this.maxSize, this.settings);\n        }\n\n        this.checkCropperPosition(false);\n      } else if (this.moveStart.type === MoveTypes.Drag) {\n        const diffX = this.cropperPositionService.getClientX(event) - this.moveStart.clientX;\n        const diffY = this.cropperPositionService.getClientY(event) - this.moveStart.clientY;\n        this.transform = Object.assign(Object.assign({}, this.transform), {\n          translateH: (((_a = this.moveStart.transform) === null || _a === void 0 ? void 0 : _a.translateH) || 0) + diffX,\n          translateV: (((_b = this.moveStart.transform) === null || _b === void 0 ? void 0 : _b.translateV) || 0) + diffY\n        });\n        this.setCssTransform();\n      }\n\n      this.cd.detectChanges();\n    }\n  }\n\n  onPinch(event) {\n    if (this.moveStart.active) {\n      if (event.stopPropagation) {\n        event.stopPropagation();\n      }\n\n      if (event.preventDefault) {\n        event.preventDefault();\n      }\n\n      if (this.moveStart.type === MoveTypes.Pinch) {\n        this.cropperPositionService.resize(event, this.moveStart, this.cropper, this.maxSize, this.settings);\n        this.checkCropperPosition(false);\n      }\n\n      this.cd.detectChanges();\n    }\n  }\n\n  moveStop() {\n    var _a;\n\n    if (this.moveStart.active) {\n      this.moveStart.active = false;\n\n      if (((_a = this.moveStart) === null || _a === void 0 ? void 0 : _a.type) === MoveTypes.Drag) {\n        this.transformChange.emit(this.transform);\n      } else {\n        this.doAutoCrop();\n      }\n    }\n  }\n\n  pinchStop() {\n    if (this.moveStart.active) {\n      this.moveStart.active = false;\n      this.doAutoCrop();\n    }\n  }\n\n  crop() {\n    var _a, _b;\n\n    if (((_b = (_a = this.loadedImage) === null || _a === void 0 ? void 0 : _a.transformed) === null || _b === void 0 ? void 0 : _b.image) != null) {\n      this.startCropImage.emit();\n      const output = this.cropService.crop(this.sourceImage, this.loadedImage, this.cropper, this.settings);\n\n      if (output != null) {\n        this.imageCropped.emit(output);\n      }\n\n      return output;\n    }\n\n    return null;\n  }\n\n  onChangesUpdateSettings(changes) {\n    this.settings.setOptionsFromChanges(changes);\n\n    if (this.settings.cropperStaticHeight && this.settings.cropperStaticWidth) {\n      this.settings.setOptions({\n        hideResizeSquares: true,\n        cropperMinWidth: this.settings.cropperStaticWidth,\n        cropperMinHeight: this.settings.cropperStaticHeight,\n        cropperMaxHeight: this.settings.cropperStaticHeight,\n        cropperMaxWidth: this.settings.cropperStaticWidth,\n        maintainAspectRatio: false\n      });\n    }\n  }\n\n  onChangesInputImage(changes) {\n    if (changes['imageChangedEvent'] || changes['imageURL'] || changes['imageBase64'] || changes['imageFile']) {\n      this.reset();\n    }\n\n    if (changes['imageChangedEvent'] && this.isValidImageChangedEvent()) {\n      this.loadImageFile(this.imageChangedEvent.target.files[0]);\n    }\n\n    if (changes['imageURL'] && this.imageURL) {\n      this.loadImageFromURL(this.imageURL);\n    }\n\n    if (changes['imageBase64'] && this.imageBase64) {\n      this.loadBase64Image(this.imageBase64);\n    }\n\n    if (changes['imageFile'] && this.imageFile) {\n      this.loadImageFile(this.imageFile);\n    }\n  }\n\n  isValidImageChangedEvent() {\n    var _a, _b, _c;\n\n    return ((_c = (_b = (_a = this.imageChangedEvent) === null || _a === void 0 ? void 0 : _a.target) === null || _b === void 0 ? void 0 : _b.files) === null || _c === void 0 ? void 0 : _c.length) > 0;\n  }\n\n  setCssTransform() {\n    var _a;\n\n    const translateUnit = ((_a = this.transform) === null || _a === void 0 ? void 0 : _a.translateUnit) || '%';\n    this.safeTransformStyle = this.sanitizer.bypassSecurityTrustStyle(`translate(${this.transform.translateH || 0}${translateUnit}, ${this.transform.translateV || 0}${translateUnit})` + ' scaleX(' + (this.transform.scale || 1) * (this.transform.flipH ? -1 : 1) + ')' + ' scaleY(' + (this.transform.scale || 1) * (this.transform.flipV ? -1 : 1) + ')' + ' rotate(' + (this.transform.rotate || 0) + 'deg)');\n  }\n\n  reset() {\n    this.imageVisible = false;\n    this.loadedImage = undefined;\n    this.safeImgDataUrl = 'data:image/png;base64,iVBORw0KGg' + 'oAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAU' + 'AAarVyFEAAAAASUVORK5CYII=';\n    this.moveStart = {\n      active: false,\n      type: null,\n      position: null,\n      x1: 0,\n      y1: 0,\n      x2: 0,\n      y2: 0,\n      clientX: 0,\n      clientY: 0\n    };\n    this.maxSize = {\n      width: 0,\n      height: 0\n    };\n    this.cropper.x1 = -100;\n    this.cropper.y1 = -100;\n    this.cropper.x2 = 10000;\n    this.cropper.y2 = 10000;\n  }\n\n  loadImageFile(file) {\n    this.loadImageService.loadImageFile(file, this.settings).then(res => this.setLoadedImage(res)).catch(err => this.loadImageError(err));\n  }\n\n  loadBase64Image(imageBase64) {\n    this.loadImageService.loadBase64Image(imageBase64, this.settings).then(res => this.setLoadedImage(res)).catch(err => this.loadImageError(err));\n  }\n\n  loadImageFromURL(url) {\n    this.loadImageService.loadImageFromURL(url, this.settings).then(res => this.setLoadedImage(res)).catch(err => this.loadImageError(err));\n  }\n\n  setLoadedImage(loadedImage) {\n    this.loadedImage = loadedImage;\n    this.safeImgDataUrl = this.sanitizer.bypassSecurityTrustResourceUrl(loadedImage.transformed.base64);\n    this.cd.markForCheck();\n  }\n\n  loadImageError(error) {\n    console.error(error);\n    this.loadImageFailed.emit();\n  }\n\n  checkImageMaxSizeRecursively() {\n    if (this.setImageMaxSizeRetries > 40) {\n      this.loadImageFailed.emit();\n    } else if (this.sourceImageLoaded()) {\n      this.setMaxSize();\n      this.setCropperScaledMinSize();\n      this.setCropperScaledMaxSize();\n      this.resetCropperPosition();\n      this.cropperReady.emit(Object.assign({}, this.maxSize));\n      this.cd.markForCheck();\n    } else {\n      this.setImageMaxSizeRetries++;\n      setTimeout(() => this.checkImageMaxSizeRecursively(), 50);\n    }\n  }\n\n  sourceImageLoaded() {\n    var _a, _b;\n\n    return ((_b = (_a = this.sourceImage) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.offsetWidth) > 0;\n  }\n\n  activatePinchGesture() {\n    if (this.Hammer) {\n      const hammer = new this.Hammer(this.wrapper.nativeElement);\n      hammer.get('pinch').set({\n        enable: true\n      });\n      hammer.on('pinchmove', this.onPinch.bind(this));\n      hammer.on('pinchend', this.pinchStop.bind(this));\n      hammer.on('pinchstart', this.startPinch.bind(this));\n    } else if (isDevMode()) {\n      console.warn('[NgxImageCropper] Could not find HammerJS - Pinch Gesture won\\'t work');\n    }\n  }\n\n  resizeCropperPosition() {\n    const sourceImageElement = this.sourceImage.nativeElement;\n\n    if (this.maxSize.width !== sourceImageElement.offsetWidth || this.maxSize.height !== sourceImageElement.offsetHeight) {\n      this.cropper.x1 = this.cropper.x1 * sourceImageElement.offsetWidth / this.maxSize.width;\n      this.cropper.x2 = this.cropper.x2 * sourceImageElement.offsetWidth / this.maxSize.width;\n      this.cropper.y1 = this.cropper.y1 * sourceImageElement.offsetHeight / this.maxSize.height;\n      this.cropper.y2 = this.cropper.y2 * sourceImageElement.offsetHeight / this.maxSize.height;\n    }\n  }\n\n  changeKeyboardStepSize(event) {\n    const key = +event.key;\n\n    if (key >= 1 && key <= 9) {\n      this.settings.stepSize = key;\n    }\n  }\n\n  keyboardMoveCropper(event) {\n    const keyboardWhiteList = ['ArrowUp', 'ArrowDown', 'ArrowRight', 'ArrowLeft'];\n\n    if (!keyboardWhiteList.includes(event.key)) {\n      return;\n    }\n\n    const moveType = event.shiftKey ? MoveTypes.Resize : MoveTypes.Move;\n    const position = event.altKey ? getInvertedPositionForKey(event.key) : getPositionForKey(event.key);\n    const moveEvent = getEventForKey(event.key, this.settings.stepSize);\n    event.preventDefault();\n    event.stopPropagation();\n    this.startMove({\n      clientX: 0,\n      clientY: 0\n    }, moveType, position);\n    this.moveImg(moveEvent);\n    this.moveStop();\n  }\n\n  setMaxSize() {\n    if (this.sourceImage) {\n      const sourceImageElement = this.sourceImage.nativeElement;\n      this.maxSize.width = sourceImageElement.offsetWidth;\n      this.maxSize.height = sourceImageElement.offsetHeight;\n      this.marginLeft = this.sanitizer.bypassSecurityTrustStyle('calc(50% - ' + this.maxSize.width / 2 + 'px)');\n    }\n  }\n\n  setCropperScaledMinSize() {\n    var _a, _b;\n\n    if ((_b = (_a = this.loadedImage) === null || _a === void 0 ? void 0 : _a.transformed) === null || _b === void 0 ? void 0 : _b.image) {\n      this.setCropperScaledMinWidth();\n      this.setCropperScaledMinHeight();\n    } else {\n      this.settings.cropperScaledMinWidth = 20;\n      this.settings.cropperScaledMinHeight = 20;\n    }\n  }\n\n  setCropperScaledMinWidth() {\n    this.settings.cropperScaledMinWidth = this.cropperMinWidth > 0 ? Math.max(20, this.cropperMinWidth / this.loadedImage.transformed.image.width * this.maxSize.width) : 20;\n  }\n\n  setCropperScaledMinHeight() {\n    if (this.maintainAspectRatio) {\n      this.settings.cropperScaledMinHeight = Math.max(20, this.settings.cropperScaledMinWidth / this.aspectRatio);\n    } else if (this.cropperMinHeight > 0) {\n      this.settings.cropperScaledMinHeight = Math.max(20, this.cropperMinHeight / this.loadedImage.transformed.image.height * this.maxSize.height);\n    } else {\n      this.settings.cropperScaledMinHeight = 20;\n    }\n  }\n\n  setCropperScaledMaxSize() {\n    var _a, _b;\n\n    if ((_b = (_a = this.loadedImage) === null || _a === void 0 ? void 0 : _a.transformed) === null || _b === void 0 ? void 0 : _b.image) {\n      const ratio = this.loadedImage.transformed.size.width / this.maxSize.width;\n      this.settings.cropperScaledMaxWidth = this.cropperMaxWidth > 20 ? this.cropperMaxWidth / ratio : this.maxSize.width;\n      this.settings.cropperScaledMaxHeight = this.cropperMaxHeight > 20 ? this.cropperMaxHeight / ratio : this.maxSize.height;\n\n      if (this.maintainAspectRatio) {\n        if (this.settings.cropperScaledMaxWidth > this.settings.cropperScaledMaxHeight * this.aspectRatio) {\n          this.settings.cropperScaledMaxWidth = this.settings.cropperScaledMaxHeight * this.aspectRatio;\n        } else if (this.settings.cropperScaledMaxWidth < this.settings.cropperScaledMaxHeight * this.aspectRatio) {\n          this.settings.cropperScaledMaxHeight = this.settings.cropperScaledMaxWidth / this.aspectRatio;\n        }\n      }\n    } else {\n      this.settings.cropperScaledMaxWidth = this.maxSize.width;\n      this.settings.cropperScaledMaxHeight = this.maxSize.height;\n    }\n  }\n\n  checkCropperPosition(maintainSize = false) {\n    if (this.cropper.x1 < 0) {\n      this.cropper.x2 -= maintainSize ? this.cropper.x1 : 0;\n      this.cropper.x1 = 0;\n    }\n\n    if (this.cropper.y1 < 0) {\n      this.cropper.y2 -= maintainSize ? this.cropper.y1 : 0;\n      this.cropper.y1 = 0;\n    }\n\n    if (this.cropper.x2 > this.maxSize.width) {\n      this.cropper.x1 -= maintainSize ? this.cropper.x2 - this.maxSize.width : 0;\n      this.cropper.x2 = this.maxSize.width;\n    }\n\n    if (this.cropper.y2 > this.maxSize.height) {\n      this.cropper.y1 -= maintainSize ? this.cropper.y2 - this.maxSize.height : 0;\n      this.cropper.y2 = this.maxSize.height;\n    }\n  }\n\n  doAutoCrop() {\n    if (this.autoCrop) {\n      this.crop();\n    }\n  }\n\n}\n\nImageComponent.ɵfac = function ImageComponent_Factory(t) {\n  return new (t || ImageComponent)(i0.ɵɵdirectiveInject(i1.DomSanitizer));\n};\n\nImageComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: ImageComponent,\n  selectors: [[\"app-image\"]],\n  inputs: {\n    multiple: \"multiple\",\n    uFormGroup: \"uFormGroup\",\n    uFormControlName: \"uFormControlName\",\n    imageChangedEvent: \"imageChangedEvent\",\n    imageURL: \"imageURL\",\n    imageBase64: \"imageBase64\",\n    imageFile: \"imageFile\",\n    transform: \"transform\",\n    allowMoveImage: \"allowMoveImage\",\n    cropper: \"cropper\",\n    disabled: \"disabled\",\n    format: \"format\",\n    maintainAspectRatio: \"maintainAspectRatio\",\n    aspectRatio: \"aspectRatio\",\n    resizeToWidth: \"resizeToWidth\",\n    resizeToHeight: \"resizeToHeight\",\n    cropperMinWidth: \"cropperMinWidth\",\n    cropperMinHeight: \"cropperMinHeight\",\n    cropperMaxHeight: \"cropperMaxHeight\",\n    cropperMaxWidth: \"cropperMaxWidth\",\n    cropperStaticWidth: \"cropperStaticWidth\",\n    cropperStaticHeight: \"cropperStaticHeight\",\n    canvasRotation: \"canvasRotation\",\n    initialStepSize: \"initialStepSize\",\n    roundCropper: \"roundCropper\",\n    onlyScaleDown: \"onlyScaleDown\",\n    imageQuality: \"imageQuality\",\n    autoCrop: \"autoCrop\",\n    backgroundColor: \"backgroundColor\",\n    containWithinAspectRatio: \"containWithinAspectRatio\",\n    hideResizeSquares: \"hideResizeSquares\",\n    alignImage: \"alignImage\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature],\n  decls: 3,\n  vars: 2,\n  consts: [[2, \"min-width\", \"20px\", \"max-width\", \"200px\", \"max-height\", \"200px\", 3, \"src\"], [\"accept\", \"*.jpb,*.png\", \"type\", \"file\", 3, \"change\"]],\n  template: function ImageComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelement(0, \"img\", 0);\n      i0.ɵɵelementStart(1, \"input\", 1);\n      i0.ɵɵlistener(\"change\", function ImageComponent_Template_input_change_1_listener($event) {\n        return ctx.onFileSelected($event);\n      });\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(2);\n    }\n\n    if (rf & 2) {\n      i0.ɵɵproperty(\"src\", ctx.getImageBase64(), i0.ɵɵsanitizeUrl);\n      i0.ɵɵadvance(2);\n      i0.ɵɵtextInterpolate1(\"\\n\", ctx.base64Image, \" \");\n    }\n  },\n  styles: [\"[_nghost-%COMP%]{display:flex;position:relative;width:100%;max-width:100%;max-height:100%;overflow:hidden;padding:5px;text-align:center}[_nghost-%COMP%] > div[_ngcontent-%COMP%]{width:100%;position:relative}[_nghost-%COMP%] > div[_ngcontent-%COMP%]   img.ngx-ic-source-image[_ngcontent-%COMP%]{max-width:100%;max-height:100%;transform-origin:center}[_nghost-%COMP%] > div[_ngcontent-%COMP%]   img.ngx-ic-source-image.ngx-ic-draggable[_ngcontent-%COMP%]{user-drag:none;-webkit-user-drag:none;user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;cursor:grab}[_nghost-%COMP%]   .ngx-ic-overlay[_ngcontent-%COMP%]{position:absolute;pointer-events:none;touch-action:none;outline:var(--cropper-overlay-color, white) solid 100vw;top:0;left:0}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]{position:absolute;display:flex;color:#53535c;background:transparent;outline:rgba(255,255,255,.3) solid 100vw;outline:var(--cropper-outline-color, rgba(255, 255, 255, .3)) solid 100vw;touch-action:none}@media (orientation: portrait){[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]{outline-width:100vh}}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]:after{position:absolute;content:\\\"\\\";top:0;bottom:0;left:0;right:0;pointer-events:none;border:dashed 1px;opacity:.75;color:inherit;z-index:1}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-move[_ngcontent-%COMP%]{width:100%;cursor:move;border:1px solid rgba(255,255,255,.5)}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]:focus   .ngx-ic-move[_ngcontent-%COMP%]{border-color:#1e90ff;border-width:2px}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize[_ngcontent-%COMP%]{position:absolute;display:inline-block;line-height:6px;padding:8px;opacity:.85;z-index:1}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize[_ngcontent-%COMP%]   .ngx-ic-square[_ngcontent-%COMP%]{display:inline-block;background:#53535C;width:6px;height:6px;border:1px solid rgba(255,255,255,.5);box-sizing:content-box}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize.ngx-ic-topleft[_ngcontent-%COMP%]{top:-12px;left:-12px;cursor:nwse-resize}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize.ngx-ic-top[_ngcontent-%COMP%]{top:-12px;left:calc(50% - 12px);cursor:ns-resize}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize.ngx-ic-topright[_ngcontent-%COMP%]{top:-12px;right:-12px;cursor:nesw-resize}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize.ngx-ic-right[_ngcontent-%COMP%]{top:calc(50% - 12px);right:-12px;cursor:ew-resize}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize.ngx-ic-bottomright[_ngcontent-%COMP%]{bottom:-12px;right:-12px;cursor:nwse-resize}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize.ngx-ic-bottom[_ngcontent-%COMP%]{bottom:-12px;left:calc(50% - 12px);cursor:ns-resize}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize.ngx-ic-bottomleft[_ngcontent-%COMP%]{bottom:-12px;left:-12px;cursor:nesw-resize}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize.ngx-ic-left[_ngcontent-%COMP%]{top:calc(50% - 12px);left:-12px;cursor:ew-resize}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize-bar[_ngcontent-%COMP%]{position:absolute;z-index:1}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize-bar.ngx-ic-top[_ngcontent-%COMP%]{top:-11px;left:11px;width:calc(100% - 22px);height:22px;cursor:ns-resize}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize-bar.ngx-ic-right[_ngcontent-%COMP%]{top:11px;right:-11px;height:calc(100% - 22px);width:22px;cursor:ew-resize}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize-bar.ngx-ic-bottom[_ngcontent-%COMP%]{bottom:-11px;left:11px;width:calc(100% - 22px);height:22px;cursor:ns-resize}[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize-bar.ngx-ic-left[_ngcontent-%COMP%]{top:11px;left:-11px;height:calc(100% - 22px);width:22px;cursor:ew-resize}[_nghost-%COMP%]   .ngx-ic-cropper.ngx-ic-round[_ngcontent-%COMP%]{outline-color:transparent}[_nghost-%COMP%]   .ngx-ic-cropper.ngx-ic-round[_ngcontent-%COMP%]:after{border-radius:100%;box-shadow:0 0 0 100vw #ffffff4d;box-shadow:0 0 0 100vw var(--cropper-outline-color, rgba(255, 255, 255, .3))}@media (orientation: portrait){[_nghost-%COMP%]   .ngx-ic-cropper.ngx-ic-round[_ngcontent-%COMP%]:after{box-shadow:0 0 0 100vh #ffffff4d;box-shadow:0 0 0 100vh var(--cropper-outline-color, rgba(255, 255, 255, .3))}}[_nghost-%COMP%]   .ngx-ic-cropper.ngx-ic-round[_ngcontent-%COMP%]   .ngx-ic-move[_ngcontent-%COMP%]{border-radius:100%}.disabled[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize[_ngcontent-%COMP%], .disabled[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-resize-bar[_ngcontent-%COMP%], .disabled[_nghost-%COMP%]   .ngx-ic-cropper[_ngcontent-%COMP%]   .ngx-ic-move[_ngcontent-%COMP%]{display:none}\"]\n});\n\n__decorate([ViewChild('wrapper', {\n  static: true\n})], ImageComponent.prototype, \"wrapper\", void 0);\n\n__decorate([ViewChild('sourceImage', {\n  static: false\n})], ImageComponent.prototype, \"sourceImage\", void 0);\n\n__decorate([HostBinding('class.disabled')], ImageComponent.prototype, \"disabled\", void 0);\n\n__decorate([Output()], ImageComponent.prototype, \"imageCropped\", void 0);\n\n__decorate([Output()], ImageComponent.prototype, \"startCropImage\", void 0);\n\n__decorate([Output()], ImageComponent.prototype, \"imageLoaded\", void 0);\n\n__decorate([Output()], ImageComponent.prototype, \"cropperReady\", void 0);\n\n__decorate([Output()], ImageComponent.prototype, \"loadImageFailed\", void 0);\n\n__decorate([Output()], ImageComponent.prototype, \"transformChange\", void 0);\n\n__decorate([HostBinding('style.text-align')], ImageComponent.prototype, \"alignImage\", void 0);\n\n__decorate([HostListener('window:resize')], ImageComponent.prototype, \"onResize\", null);\n\n__decorate([HostListener('document:mousemove', ['$event']), HostListener('document:touchmove', ['$event'])], ImageComponent.prototype, \"moveImg\", null);\n\n__decorate([HostListener('document:mouseup'), HostListener('document:touchend')], ImageComponent.prototype, \"moveStop\", null);","map":null,"metadata":{},"sourceType":"module"}