{"ast":null,"code":"import { resizeCanvas } from '../utils/resize.utils';\nimport { percentage } from '../utils/percentage.utils';\nimport * as i0 from \"@angular/core\";\nexport let CropService = /*#__PURE__*/(() => {\n  class CropService {\n    crop(sourceImage, loadedImage, cropper, settings) {\n      const imagePosition = this.getImagePosition(sourceImage, loadedImage, cropper, settings);\n      const width = imagePosition.x2 - imagePosition.x1;\n      const height = imagePosition.y2 - imagePosition.y1;\n      const cropCanvas = document.createElement('canvas');\n      cropCanvas.width = width;\n      cropCanvas.height = height;\n      const ctx = cropCanvas.getContext('2d');\n\n      if (!ctx) {\n        return null;\n      }\n\n      if (settings.backgroundColor != null) {\n        ctx.fillStyle = settings.backgroundColor;\n        ctx.fillRect(0, 0, width, height);\n      }\n\n      const scaleX = (settings.transform.scale || 1) * (settings.transform.flipH ? -1 : 1);\n      const scaleY = (settings.transform.scale || 1) * (settings.transform.flipV ? -1 : 1);\n      const {\n        translateH,\n        translateV\n      } = this.getCanvasTranslate(sourceImage, loadedImage, settings);\n      const transformedImage = loadedImage.transformed;\n      ctx.setTransform(scaleX, 0, 0, scaleY, transformedImage.size.width / 2 + translateH, transformedImage.size.height / 2 + translateV);\n      ctx.translate(-imagePosition.x1 / scaleX, -imagePosition.y1 / scaleY);\n      ctx.rotate((settings.transform.rotate || 0) * Math.PI / 180);\n      ctx.drawImage(transformedImage.image, -transformedImage.size.width / 2, -transformedImage.size.height / 2);\n      const output = {\n        width,\n        height,\n        imagePosition,\n        cropperPosition: Object.assign({}, cropper)\n      };\n\n      if (settings.containWithinAspectRatio) {\n        output.offsetImagePosition = this.getOffsetImagePosition(sourceImage, loadedImage, cropper, settings);\n      }\n\n      const resizeRatio = this.getResizeRatio(width, height, settings);\n\n      if (resizeRatio !== 1) {\n        output.width = Math.round(width * resizeRatio);\n        output.height = settings.maintainAspectRatio ? Math.round(output.width / settings.aspectRatio) : Math.round(height * resizeRatio);\n        resizeCanvas(cropCanvas, output.width, output.height);\n      }\n\n      output.base64 = cropCanvas.toDataURL('image/' + settings.format, this.getQuality(settings));\n      return output;\n    }\n\n    getCanvasTranslate(sourceImage, loadedImage, settings) {\n      if (settings.transform.translateUnit === 'px') {\n        const ratio = this.getRatio(sourceImage, loadedImage);\n        return {\n          translateH: (settings.transform.translateH || 0) * ratio,\n          translateV: (settings.transform.translateV || 0) * ratio\n        };\n      } else {\n        return {\n          translateH: settings.transform.translateH ? percentage(settings.transform.translateH, loadedImage.transformed.size.width) : 0,\n          translateV: settings.transform.translateV ? percentage(settings.transform.translateV, loadedImage.transformed.size.height) : 0\n        };\n      }\n    }\n\n    getRatio(sourceImage, loadedImage) {\n      const sourceImageElement = sourceImage.nativeElement;\n      return loadedImage.transformed.size.width / sourceImageElement.offsetWidth;\n    }\n\n    getImagePosition(sourceImage, loadedImage, cropper, settings) {\n      const ratio = this.getRatio(sourceImage, loadedImage);\n      const out = {\n        x1: Math.round(cropper.x1 * ratio),\n        y1: Math.round(cropper.y1 * ratio),\n        x2: Math.round(cropper.x2 * ratio),\n        y2: Math.round(cropper.y2 * ratio)\n      };\n\n      if (!settings.containWithinAspectRatio) {\n        out.x1 = Math.max(out.x1, 0);\n        out.y1 = Math.max(out.y1, 0);\n        out.x2 = Math.min(out.x2, loadedImage.transformed.size.width);\n        out.y2 = Math.min(out.y2, loadedImage.transformed.size.height);\n      }\n\n      return out;\n    }\n\n    getOffsetImagePosition(sourceImage, loadedImage, cropper, settings) {\n      const canvasRotation = settings.canvasRotation + loadedImage.exifTransform.rotate;\n      const sourceImageElement = sourceImage.nativeElement;\n      const ratio = loadedImage.transformed.size.width / sourceImageElement.offsetWidth;\n      let offsetX;\n      let offsetY;\n\n      if (canvasRotation % 2) {\n        offsetX = (loadedImage.transformed.size.width - loadedImage.original.size.height) / 2;\n        offsetY = (loadedImage.transformed.size.height - loadedImage.original.size.width) / 2;\n      } else {\n        offsetX = (loadedImage.transformed.size.width - loadedImage.original.size.width) / 2;\n        offsetY = (loadedImage.transformed.size.height - loadedImage.original.size.height) / 2;\n      }\n\n      const out = {\n        x1: Math.round(cropper.x1 * ratio) - offsetX,\n        y1: Math.round(cropper.y1 * ratio) - offsetY,\n        x2: Math.round(cropper.x2 * ratio) - offsetX,\n        y2: Math.round(cropper.y2 * ratio) - offsetY\n      };\n\n      if (!settings.containWithinAspectRatio) {\n        out.x1 = Math.max(out.x1, 0);\n        out.y1 = Math.max(out.y1, 0);\n        out.x2 = Math.min(out.x2, loadedImage.transformed.size.width);\n        out.y2 = Math.min(out.y2, loadedImage.transformed.size.height);\n      }\n\n      return out;\n    }\n\n    getResizeRatio(width, height, settings) {\n      const ratioWidth = settings.resizeToWidth / width;\n      const ratioHeight = settings.resizeToHeight / height;\n      const ratios = new Array();\n\n      if (settings.resizeToWidth > 0) {\n        ratios.push(ratioWidth);\n      }\n\n      if (settings.resizeToHeight > 0) {\n        ratios.push(ratioHeight);\n      }\n\n      const result = ratios.length === 0 ? 1 : Math.min(...ratios);\n\n      if (result > 1 && !settings.onlyScaleDown) {\n        return result;\n      }\n\n      return Math.min(result, 1);\n    }\n\n    getQuality(settings) {\n      return Math.min(1, Math.max(0, settings.imageQuality / 100));\n    }\n\n  }\n\n  CropService.ɵfac = function CropService_Factory(t) {\n    return new (t || CropService)();\n  };\n\n  CropService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: CropService,\n    factory: CropService.ɵfac,\n    providedIn: 'root'\n  });\n  return CropService;\n})();","map":null,"metadata":{},"sourceType":"module"}