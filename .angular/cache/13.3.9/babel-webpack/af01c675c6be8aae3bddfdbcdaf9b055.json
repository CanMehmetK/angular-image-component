{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { getTransformationsFromExifData, supportsAutomaticRotation } from '../utils/exif.utils';\nimport * as i0 from \"@angular/core\";\nexport let LoadImageService = /*#__PURE__*/(() => {\n  class LoadImageService {\n    constructor() {\n      this.autoRotateSupported = supportsAutomaticRotation();\n    }\n\n    loadImageFile(file, cropperSettings) {\n      console.log('--');\n      return new Promise((resolve, reject) => {\n        const fileReader = new FileReader();\n\n        fileReader.onload = event => {\n          this.loadImage(event.target.result, file.type, cropperSettings).then(resolve).catch(reject);\n        };\n\n        fileReader.readAsDataURL(file);\n      });\n    }\n\n    loadImage(imageBase64, imageType, cropperSettings) {\n      if (!this.isValidImageType(imageType)) {\n        return Promise.reject(new Error('Invalid image type'));\n      }\n\n      return this.loadBase64Image(imageBase64, cropperSettings);\n    }\n\n    isValidImageType(type) {\n      return /image\\/(png|jpg|jpeg|bmp|gif|tiff|webp|x-icon|vnd.microsoft.icon)/.test(type);\n    }\n\n    loadImageFromURL(url, cropperSettings) {\n      console.log('--');\n      return new Promise((resolve, reject) => {\n        const img = new Image();\n\n        img.onerror = () => reject;\n\n        img.onload = () => {\n          const canvas = document.createElement('canvas');\n          const context = canvas.getContext('2d');\n          canvas.width = img.width;\n          canvas.height = img.height;\n          context === null || context === void 0 ? void 0 : context.drawImage(img, 0, 0);\n          this.loadBase64Image(canvas.toDataURL(), cropperSettings).then(resolve);\n        };\n\n        img.crossOrigin = 'anonymous';\n        img.src = url;\n      });\n    }\n\n    loadBase64Image(imageBase64, cropperSettings) {\n      return new Promise((resolve, reject) => {\n        const originalImage = new Image();\n\n        originalImage.onload = () => resolve({\n          originalImage,\n          originalBase64: imageBase64\n        });\n\n        originalImage.onerror = reject;\n        originalImage.src = imageBase64;\n      }).then(res => this.transformImageBase64(res, cropperSettings));\n    }\n\n    transformImageBase64(res, cropperSettings) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const autoRotate = yield this.autoRotateSupported;\n        const exifTransform = yield getTransformationsFromExifData(autoRotate ? -1 : res.originalBase64);\n\n        if (!res.originalImage || !res.originalImage.complete) {\n          return Promise.reject(new Error('No image loaded'));\n        }\n\n        const loadedImage = {\n          original: {\n            base64: res.originalBase64,\n            image: res.originalImage,\n            size: {\n              width: res.originalImage.naturalWidth,\n              height: res.originalImage.naturalHeight\n            }\n          },\n          exifTransform\n        };\n        return this.transformLoadedImage(loadedImage, cropperSettings);\n      });\n    }\n\n    transformLoadedImage(loadedImage, cropperSettings) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const canvasRotation = cropperSettings.canvasRotation + loadedImage.exifTransform.rotate;\n        const originalSize = {\n          width: loadedImage.original.image.naturalWidth,\n          height: loadedImage.original.image.naturalHeight\n        };\n\n        if (canvasRotation === 0 && !loadedImage.exifTransform.flip && !cropperSettings.containWithinAspectRatio) {\n          return {\n            original: {\n              base64: loadedImage.original.base64,\n              image: loadedImage.original.image,\n              size: Object.assign({}, originalSize)\n            },\n            transformed: {\n              base64: loadedImage.original.base64,\n              image: loadedImage.original.image,\n              size: Object.assign({}, originalSize)\n            },\n            exifTransform: loadedImage.exifTransform\n          };\n        }\n\n        const transformedSize = this.getTransformedSize(originalSize, loadedImage.exifTransform, cropperSettings);\n        const canvas = document.createElement('canvas');\n        canvas.width = transformedSize.width;\n        canvas.height = transformedSize.height;\n        const ctx = canvas.getContext('2d');\n        ctx === null || ctx === void 0 ? void 0 : ctx.setTransform(loadedImage.exifTransform.flip ? -1 : 1, 0, 0, 1, canvas.width / 2, canvas.height / 2);\n        ctx === null || ctx === void 0 ? void 0 : ctx.rotate(Math.PI * (canvasRotation / 2));\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(loadedImage.original.image, -originalSize.width / 2, -originalSize.height / 2);\n        const transformedBase64 = canvas.toDataURL();\n        const transformedImage = yield this.loadImageFromBase64(transformedBase64);\n        return {\n          original: {\n            base64: loadedImage.original.base64,\n            image: loadedImage.original.image,\n            size: Object.assign({}, originalSize)\n          },\n          transformed: {\n            base64: transformedBase64,\n            image: transformedImage,\n            size: {\n              width: transformedImage.width,\n              height: transformedImage.height\n            }\n          },\n          exifTransform: loadedImage.exifTransform\n        };\n      });\n    }\n\n    loadImageFromBase64(imageBase64) {\n      return new Promise((resolve, reject) => {\n        const image = new Image();\n\n        image.onload = () => resolve(image);\n\n        image.onerror = reject;\n        image.src = imageBase64;\n      });\n    }\n\n    getTransformedSize(originalSize, exifTransform, cropperSettings) {\n      const canvasRotation = cropperSettings.canvasRotation + exifTransform.rotate;\n\n      if (cropperSettings.containWithinAspectRatio) {\n        if (canvasRotation % 2) {\n          const minWidthToContain = originalSize.width * cropperSettings.aspectRatio;\n          const minHeightToContain = originalSize.height / cropperSettings.aspectRatio;\n          return {\n            width: Math.max(originalSize.height, minWidthToContain),\n            height: Math.max(originalSize.width, minHeightToContain)\n          };\n        } else {\n          const minWidthToContain = originalSize.height * cropperSettings.aspectRatio;\n          const minHeightToContain = originalSize.width / cropperSettings.aspectRatio;\n          return {\n            width: Math.max(originalSize.width, minWidthToContain),\n            height: Math.max(originalSize.height, minHeightToContain)\n          };\n        }\n      }\n\n      if (canvasRotation % 2) {\n        return {\n          height: originalSize.width,\n          width: originalSize.height\n        };\n      }\n\n      return {\n        width: originalSize.width,\n        height: originalSize.height\n      };\n    }\n\n  }\n\n  LoadImageService.ɵfac = function LoadImageService_Factory(t) {\n    return new (t || LoadImageService)();\n  };\n\n  LoadImageService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: LoadImageService,\n    factory: LoadImageService.ɵfac,\n    providedIn: 'root'\n  });\n  return LoadImageService;\n})();","map":null,"metadata":{},"sourceType":"module"}